using System.CodeDom.Compiler;
using System.Globalization;
using System.Text;
using Architect.Build.SourceGenerator.Common;
using Architect.Build.SourceGenerator.Models;
using Microsoft.CodeAnalysis;

namespace Architect.Build.SourceGenerator;

internal partial class BindableGenerator
{
    private static string GenerateSourceCode(
        ClassInfo classInfo,
        bool supportsPartialProps,
        CancellationToken cancellationToken
    )
    {
        cancellationToken.ThrowIfCancellationRequested();
        StringBuilder builder = new();
        using StringWriter writer = new(builder, CultureInfo.InvariantCulture);
        using IndentedTextWriter source = new(writer, "\t");

        if (!classInfo.Modifiers.Contains("partial"))
            return string.Empty;

        cancellationToken.ThrowIfCancellationRequested();
        WriteNamespaceAndUsings(source, classInfo);
        cancellationToken.ThrowIfCancellationRequested();

        WriteClassDeclaration(source, classInfo, supportsPartialProps, cancellationToken);

        return builder.ToString();
    }

    private static void WriteNamespaceAndUsings(IndentedTextWriter source, ClassInfo classInfo)
    {
        source.WriteLine("using Architect.Common.Interfaces;");
        source.WriteLine();

        if (!classInfo.Namespace.IsGlobal)
            source.WriteLine($"namespace {classInfo.Namespace.Name};");
    }

    private static void WriteClassDeclaration(
        IndentedTextWriter source,
        ClassInfo classInfo,
        bool supportsPartialProps,
        CancellationToken cancellationToken
    )
    {
        cancellationToken.ThrowIfCancellationRequested();
        source.WriteLine();
        source.WriteLine("// <auto-generated/>");
        source.WriteLine("#nullable enable");
        source.WriteLine();

        cancellationToken.ThrowIfCancellationRequested();
        source.WriteLine(
            $"{string.Join(" ", classInfo.Modifiers)} class {classInfo.Name} : IBindable"
        );
        source.WriteLine("{");
        source.Indent++;
        source.WriteLine("public event Action<string, object> PropertyChanged;");
        source.WriteLine();
        cancellationToken.ThrowIfCancellationRequested();

        WriteProperties(source, classInfo, supportsPartialProps, cancellationToken);
        source.Indent--;
        source.WriteLine("}");
    }

    private static void WriteProperties(
        IndentedTextWriter source,
        ClassInfo classInfo,
        bool supportsPartialProps,
        CancellationToken cancellationToken
    )
    {
        foreach (PropertyInfo propertyInfo in classInfo.Properties)
        {
            cancellationToken.ThrowIfCancellationRequested();

            if (propertyInfo.Modifiers.Contains("partial") && !supportsPartialProps)
                continue;

            if (supportsPartialProps)
                source.WriteLine($"private {propertyInfo.Type} {propertyInfo.BackingFieldName};");

            var backingFieldName = supportsPartialProps
                ? propertyInfo.BackingFieldName
                : propertyInfo.Name;
            source.WriteLine();

            source.WriteLine("// <auto-generated/>");
            source.WriteLine("#nullable enable");
            source.WriteLine();

            var propertyName = supportsPartialProps
                ? propertyInfo.Name
                : Utils.ToAlpha(propertyInfo.Name);

            if (supportsPartialProps)
                source.WriteLine(
                    $"{string.Join(" ", propertyInfo.Modifiers)} {propertyInfo.Type} {propertyName}"
                );
            else
                source.WriteLine($"public {propertyInfo.Type} {propertyName}");

            source.WriteLine("{");
            source.Indent++;

            source.WriteLine($"get => GetProperty<{propertyInfo.Type}>(nameof({propertyName}))!;");
            source.WriteLine($"set => SetProperty(nameof({propertyName}), value);");

            source.Indent--;
            source.WriteLine("}");
            source.WriteLine();
        }

        List<(string, string, string)> propertyNames =
        [
            .. classInfo.Properties.Select(p =>
                (
                    supportsPartialProps ? p.Name : Utils.ToAlpha(p.Name),
                    supportsPartialProps ? p.BackingFieldName : p.Name,
                    p.Type
                )
            ),
        ];

        WriteGetPropertyMethod(source, propertyNames, cancellationToken);
        WriteSetPropertyMethod(source, propertyNames, cancellationToken);
    }

    private static void WriteGetPropertyMethod(
        IndentedTextWriter source,
        List<(string, string, string)> propertyNames,
        CancellationToken cancellationToken
    )
    {
        source.WriteLine("// <auto-generated/>");
        source.WriteLine("#nullable enable");
        source.WriteLine();

        source.WriteLine(
            "public T? GetProperty<T>(string propertyName, T? defaultValue = default) => propertyName switch"
        );
        source.WriteLine("{");
        source.Indent++;
        foreach (var (propertyName, propertyBackingField, _) in propertyNames)
        {
            cancellationToken.ThrowIfCancellationRequested();
            source.WriteLine(@$"""{propertyName}"" => (T)(object){propertyBackingField},");
        }
        source.WriteLine(
            "_ => throw new ArgumentException($\"Property {propertyName} not found\", nameof(propertyName))"
        );
        source.Indent--;
        source.WriteLine("};");
        source.WriteLine();
    }

    private static void WriteSetPropertyMethod(
        IndentedTextWriter source,
        List<(string, string, string)> propertyNames,
        CancellationToken cancellationToken
    )
    {
        source.WriteLine("public void SetProperty<T>(string propertyName, T value)");
        source.WriteLine("{");

        source.Indent++;
        source.WriteLine("var currentValue = GetProperty<T>(propertyName);");
        source.WriteLine();
        source.WriteLine("if (EqualityComparer<T>.Default.Equals(currentValue, value)) return;");
        source.WriteLine();
        source.WriteLine("switch (propertyName)");
        source.WriteLine("{");
        source.Indent++;
        foreach (var (propertyName, propertyBackingField, propertyType) in propertyNames)
        {
            cancellationToken.ThrowIfCancellationRequested();
            source.WriteLine($"case \"{propertyName}\":");
            source.Indent++;
            source.WriteLine(
                @$"{propertyBackingField} = value as {propertyType} ?? throw new InvalidCastException($""Cannot cast {{value}} to {propertyType}"");"
            );
            source.Indent--;
            source.WriteLine("break;");
            source.WriteLine();
        }
        source.WriteLine("default:");
        source.Indent++;
        source.WriteLine(
            @"throw new ArgumentException($""Property {propertyName} not found"", nameof(propertyName));"
        );
        source.Indent--;
        source.WriteLine("break;");

        source.Indent--;
        source.WriteLine("};");
        source.WriteLine();

        source.WriteLine(@"PropertyChanged.Invoke(propertyName, value);");

        source.Indent--;
        source.WriteLine("}");
        source.WriteLine();
    }

}
