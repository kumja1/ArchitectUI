using System.CodeDom.Compiler;
using System.Diagnostics;
using System.Globalization;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Architect.Build.SourceGenerator;

internal partial class BindableGenerator
{
    private static IEnumerable<(string typeName, string source)> GenerateSourceCode(
        IReadOnlyList<MethodDeclarationSyntax> candidateMethods,
        Compilation compilation,
        CancellationToken cancellationToken
    )
    {
        StringBuilder builder = new();
        using StringWriter writer = new(builder, CultureInfo.InvariantCulture);
        using IndentedTextWriter source = new(writer, "\t");

        foreach (IGrouping<TypeDeclarationSyntax, MethodDeclarationSyntax> candidateMethod in [])
        {
            SemanticModel semanticModel = compilation.GetSemanticModel(
                candidateMethod.Key.SyntaxTree
            );

            INamedTypeSymbol? typeSymbol = semanticModel.GetDeclaredSymbol(
                candidateMethod.Key,
                cancellationToken
            );

            if (typeSymbol is null)
            {
                continue;
            }

            source.WriteLine("// <auto-generated/>");
            source.WriteLine("#nullable enable");
            source.WriteLine();

            if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                source.WriteLine($"namespace {typeSymbol.ContainingNamespace}");
                source.WriteLine("{");
                source.Indent++;
            }

            source.WriteLine(
                $"partial {candidateMethod.Key.Keyword} {candidateMethod.Key.Identifier.ValueText}"
            );
            source.WriteLine("{");
            source.Indent++;

            foreach (MethodDeclarationSyntax methodDeclaration in candidateMethod)
            {
                source.WriteLine(
                    $@"{methodDeclaration.Modifiers} string {methodDeclaration.Identifier.ValueText}() => ""Hello, World!"";"
                );
            }

            source.Indent--;
            source.WriteLine("}");

            if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                source.Indent--;
                source.WriteLine("}");
            }

            Debug.Assert(source.Indent == 0);

            yield return (candidateMethod.Key.Identifier.ValueText, writer.ToString());
            _ = builder.Clear();
        }
    }
}
